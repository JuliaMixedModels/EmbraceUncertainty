<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.29">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Appendix B — Linear algebra for linear models – Embrace Uncertainty</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./aGHQ.html" rel="next">
<link href="./datatables.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7edfaf1c48232bdc7da6ab4de57864f3.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ace8ecb178961cc53692af416c51b0eb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./datatables.html">Appendices</a></li><li class="breadcrumb-item"><a href="./linalg.html"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Linear algebra for linear models</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Embrace Uncertainty</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">A simple, linear, mixed-effects model</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./multiple.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Models with multiple random-effects terms</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./longitudinal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Models for longitudinal data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./largescaledesigned.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">A large-scale designed experiment</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./largescaleobserved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">A large-scale observational study</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glmmbernoulli.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Generalized linear mixed models for binary responses</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./datatables.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Working with data tables</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./linalg.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Linear algebra for linear models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./aGHQ.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">GLMM log-likelihood</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#matrix-vector-representation-of-linear-models" id="toc-matrix-vector-representation-of-linear-models" class="nav-link active" data-scroll-target="#matrix-vector-representation-of-linear-models"><span class="header-section-number">B.1</span> Matrix-vector representation of linear models</a></li>
  <li><a href="#sec-multivariateGaussian" id="toc-sec-multivariateGaussian" class="nav-link" data-scroll-target="#sec-multivariateGaussian"><span class="header-section-number">B.2</span> The multivariate Gaussian distribution</a>
  <ul class="collapse">
  <li><a href="#some-properties-of-triangular-matrices" id="toc-some-properties-of-triangular-matrices" class="nav-link" data-scroll-target="#some-properties-of-triangular-matrices"><span class="header-section-number">B.2.1</span> Some properties of triangular matrices</a></li>
  <li><a href="#sec-cholesky" id="toc-sec-cholesky" class="nav-link" data-scroll-target="#sec-cholesky"><span class="header-section-number">B.2.2</span> Positive definiteness and the Cholesky factor</a></li>
  <li><a href="#sec-mvgaussian" id="toc-sec-mvgaussian" class="nav-link" data-scroll-target="#sec-mvgaussian"><span class="header-section-number">B.2.3</span> Density of the multivariate Gaussian</a></li>
  <li><a href="#linear-functions-of-a-multivariate-gaussian" id="toc-linear-functions-of-a-multivariate-gaussian" class="nav-link" data-scroll-target="#linear-functions-of-a-multivariate-gaussian"><span class="header-section-number">B.2.4</span> Linear functions of a multivariate Gaussian</a></li>
  </ul></li>
  <li><a href="#back-to-the-linear-model" id="toc-back-to-the-linear-model" class="nav-link" data-scroll-target="#back-to-the-linear-model"><span class="header-section-number">B.3</span> Back to the linear model</a></li>
  <li><a href="#minimizing-the-sum-of-squared-residuals" id="toc-minimizing-the-sum-of-squared-residuals" class="nav-link" data-scroll-target="#minimizing-the-sum-of-squared-residuals"><span class="header-section-number">B.4</span> Minimizing the sum of squared residuals</a></li>
  <li><a href="#numerical-example" id="toc-numerical-example" class="nav-link" data-scroll-target="#numerical-example"><span class="header-section-number">B.5</span> Numerical example</a></li>
  <li><a href="#sec-matrixdecomp" id="toc-sec-matrixdecomp" class="nav-link" data-scroll-target="#sec-matrixdecomp"><span class="header-section-number">B.6</span> Alternative decompositions of X</a></li>
  <li><a href="#sec-lmmtheory" id="toc-sec-lmmtheory" class="nav-link" data-scroll-target="#sec-lmmtheory"><span class="header-section-number">B.7</span> Linear mixed-effects models</a></li>
  <li><a href="#sec-REML" id="toc-sec-REML" class="nav-link" data-scroll-target="#sec-REML"><span class="header-section-number">B.8</span> The REML criterion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./datatables.html">Appendices</a></li><li class="breadcrumb-item"><a href="./linalg.html"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Linear algebra for linear models</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-linalg" class="quarto-section-identifier">Appendix B — Linear algebra for linear models</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Attach the packages to be used in this appendix</p>
<div id="2" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">EmbraceUncertainty</span>: dataset</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">MixedModels</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In this appendix we describe properties of the multivariate Gaussian (or “normal”) distribution and how linear models and linear mixed models can be formulated in terms of this distribution.</p>
<p>We also describe some methods in numerical linear algebra that are particularly useful in working with linear models. One of the strengths of the Julia language is the <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">LinearAlgebra</a> package in the standard library. The implementation of multi-dimensional <em>arrays</em>, including one-dimensional <em>vectors</em> and two-dimensional <em>matrices</em>, is part of the base Julia language. The added value of the <em>LinearAlgebra</em> package is compact representations of special types of matrices and methods for and with matrix decompositions or <a href="https://nhigham.com/2022/05/18/the-big-six-matrix-factorizations/">factorizations</a>.</p>
<p>The purpose of these descriptions is to motivate a representation of a linear mixed model that allows for fast and stable estimation of the parameters. The estimation process requires iterative optimization of some of the parameters in the model to minimize an objective function. Often this optimization requires hundreds or thousands of evaluations of the objective at different values of the parameters and these evaluations dominate the overall estimation time. Thus, a fast, efficient method for evaluating the objective is crucial to making the whole process fast.</p>
<section id="matrix-vector-representation-of-linear-models" class="level2" data-number="B.1">
<h2 data-number="B.1" class="anchored" data-anchor-id="matrix-vector-representation-of-linear-models"><span class="header-section-number">B.1</span> Matrix-vector representation of linear models</h2>
<p>A linear statistical model is often written as an expression for each element of the <span class="math inline">\(n\)</span>-dimensional response vector, <span class="math inline">\({\mathbf{y}}\)</span>, as, e.g. <span id="eq-elementlinmod"><span class="math display">\[
y_i = \beta_1 x_{i,1} + \beta_2 x_{i,2} + \dots + \beta_p x_{i,p} + \epsilon_i, \quad i=1,\dots, n
\tag{B.1}\]</span></span> and some additional description like “where the <span class="math inline">\(\epsilon_i,i=1,\dots,n\)</span> are independently and identically distributed as <span class="math inline">\({\mathcal{N}}(0, \sigma^2)\)</span>”.</p>
<p>An alternative is to write the model in terms of the <span class="math inline">\(n\)</span>-dimensional <em>response vector</em>, <span class="math inline">\({\mathbf{y}}\)</span>, an <span class="math inline">\(n\times p\)</span> <em>model matrix</em>, <span class="math inline">\({\mathbf{X}}\)</span>, and a <span class="math inline">\(p\)</span>-dimensional <em>coefficient vector</em>, <span class="math inline">\({\boldsymbol{\beta}}\)</span>, as <span id="eq-mvnlinmod"><span class="math display">\[
{\mathcal{Y}}\sim{\mathcal{N}}\left({\mathbf{X}}{\boldsymbol{\beta}},\sigma^2{\mathbf{I}}\right),
\tag{B.2}\]</span></span> where <span class="math inline">\({\mathcal{N}}\)</span> denotes the multivariate Gaussian distribution with mean <span class="math inline">\({\boldsymbol{\mu}}={\mathbf{X}}{\boldsymbol{\beta}}\)</span> and variance-covariance matrix <span class="math inline">\({\boldsymbol{\Sigma}}=\sigma^2{\mathbf{I}}\)</span>. (In what follows we will refer to the <em>variance-covariance matrix</em> as simply the <em>covariance matrix</em>.)</p>
<p>Before considering properties of and computational methods for the model <a href="#eq-mvnlinmod" class="quarto-xref">Equation&nbsp;<span>B.2</span></a> we will describe some of the properties of the <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution">multivariate Gaussian distribution</a>.</p>
</section>
<section id="sec-multivariateGaussian" class="level2" data-number="B.2">
<h2 data-number="B.2" class="anchored" data-anchor-id="sec-multivariateGaussian"><span class="header-section-number">B.2</span> The multivariate Gaussian distribution</h2>
<p>Just as a univariate Gaussian distribution can be written by specifying the (scalar) mean, <span class="math inline">\(\mu\)</span>, and the variance, <span class="math inline">\(\sigma^2\)</span>, as <span class="math inline">\({\mathcal{N}}(\mu, \sigma^2)\)</span>, a multivariate Gaussian distribution is characterized by its <span class="math inline">\(n\)</span>-dimensional mean vector, <span class="math inline">\({\boldsymbol{\mu}}\)</span>, and its <span class="math inline">\(n\times n\)</span> variance-covariance matrix, <span class="math inline">\({\boldsymbol{\Sigma}}\)</span>, as <span class="math inline">\({\mathcal{N}}({\boldsymbol{\mu}}, {\boldsymbol{\Sigma}})\)</span>.</p>
<p>The density function for a univariate Gaussian distribution is the familiar “bell curve” <span id="eq-univariateGaussianpdf"><span class="math display">\[
f(x; \mu, \sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(\frac{-\left(x-\mu\right)^2}{2\sigma^2}\right)
\tag{B.3}\]</span></span> and probabilities defined by this density are most easily evaluated by <em>standardizing</em> the deviation, <span class="math inline">\(x-\mu\)</span>, as <span class="math inline">\(z=\frac{x-\mu}{\sigma}\)</span>, which is why <span class="math inline">\(\sigma\)</span> is called the <em>standard deviation</em>.</p>
<p>To be able to evaluate <span class="math inline">\(\sigma\)</span>, the variance, <span class="math inline">\(\sigma^2\)</span>, must be positive, or at least non-negative. If <span class="math inline">\(\sigma^2=0\)</span> then all the probability is concentrated at a single point, <span class="math inline">\(x=\mu\)</span>, and we no longer have a probability density, in the usual way of thinking of one. The density shrinks to a point mass and the distribution is said to be <a href="https://en.wikipedia.org/wiki/Degenerate_distribution">degenerate</a>.</p>
<p>Similar constraints apply to a covariance matrix, <span class="math inline">\({\boldsymbol{\Sigma}}\)</span>. Because the covariance of the i’th and j’th elements does not depend upon the order in which we write them, <span class="math inline">\({\boldsymbol{\Sigma}}\)</span> must be symmetric. That is, <span id="eq-Sigmasym"><span class="math display">\[
{\boldsymbol{\Sigma}}' = {\boldsymbol{\Sigma}}.
\tag{B.4}\]</span></span> Furthermore, to define a proper multivariate density, <span class="math inline">\({\boldsymbol{\Sigma}}\)</span> must be <a href="https://en.wikipedia.org/wiki/Definite_matrix">positive definite</a>, which means that for any non-zero vector, <span class="math inline">\({\mathbf{x}}\)</span>, the <em>quadratic form</em> defined by <span class="math inline">\({\boldsymbol{\Sigma}}\)</span> must be positive. That is <span id="eq-positiveDef"><span class="math display">\[
{\mathbf{x}}'{\boldsymbol{\Sigma}}{\mathbf{x}}&gt;0,\quad\forall\,{\mathbf{x}}\ne\mathbf{0} .
\tag{B.5}\]</span></span> (the symbol <span class="math inline">\(\forall\)</span> means “for all”). Positive definiteness implies that the <em>precision matrix</em>, <span class="math inline">\({\boldsymbol{\Sigma}}^{-1}\)</span>, exists and is also positive definite. It also implies that there are “matrix square roots” of <span class="math inline">\({\boldsymbol{\Sigma}}\)</span> in the sense that there are matrices <span class="math inline">\(\mathbf{A}\)</span> such that <span class="math inline">\(\mathbf{A}'\mathbf{A}={\boldsymbol{\Sigma}}\)</span>. (The reason for writing <span class="math inline">\(\mathbf{A}'\mathbf{A}\)</span> and not simply the square of <span class="math inline">\(\mathbf{A}\)</span> is that <span class="math inline">\(\mathbf{A}\)</span> is not required to be symmetric but <span class="math inline">\(\mathbf{A}'\mathbf{A}\)</span> will be symmetric, even in <span class="math inline">\(\mathbf{A}\)</span> is not.)</p>
<p>One such “square root” of a positive definite <span class="math inline">\({\boldsymbol{\Sigma}}\)</span> is the <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky factor</a>, which corresponds to <span class="math inline">\(n\times n\)</span> upper-triangular matrix, <span class="math inline">\({\mathbf{R}}\)</span>, such that <span id="eq-uppercholesky"><span class="math display">\[
{\boldsymbol{\Sigma}}={\mathbf{R}}'{\mathbf{R}}.
\tag{B.6}\]</span></span> This factor is usually called <span class="math inline">\({\mathbf{R}}\)</span> because it appears without the transpose as the right-hand multiplicant in <a href="#eq-uppercholesky" class="quarto-xref">Equation&nbsp;<span>B.6</span></a>. An alternative expression is written with the lower-triangular <span class="math inline">\(\mathbf{L}\)</span> on the left as <span id="eq-lowerCholesky"><span class="math display">\[
{\boldsymbol{\Sigma}}=\mathbf{L}\mathbf{L}',
\tag{B.7}\]</span></span> with the obvious relationship that <span class="math inline">\(\mathbf{L}={\mathbf{R}}'\)</span>. To add to the confusion, the <code>cholesky</code> function in the <em>LinearAlgebra</em> package produces a factorization where the lower-triangular factor on the left is called <code>L</code> and the upper-triangular factor on the right is called <code>U</code>.</p>
<p>The factor <span class="math inline">\({\mathbf{R}}\)</span> or <span class="math inline">\(\mathbf{L}\)</span> can be evaluated directly from the elements of <span class="math inline">\({\boldsymbol{\Sigma}}\)</span>. For example, the non-zeros in the first two rows of <span class="math inline">\(\mathbf{L}\)</span> are evaluated as <span id="eq-lowerCholtworows"><span class="math display">\[
\begin{aligned}
\mathbf{L}_{1,1}&amp;=\sqrt{{\boldsymbol{\Sigma}}_{1,1}}\\
\mathbf{L}_{2,1}&amp;={\boldsymbol{\Sigma}}_{2,1}/\mathbf{L}_{1,1}\\
\mathbf{L}_{2,2}&amp;=\sqrt{{\boldsymbol{\Sigma}}_{2,2}-\mathbf{L}_{2,1}^2}
\end{aligned}
\tag{B.8}\]</span></span> Evaluating the diagonal elements involves taking a square root. By convention we choose the positive square root for the Cholesky factor with the result that the diagonal elements of <span class="math inline">\(\mathbf{L}\)</span> are all positive.</p>
<section id="some-properties-of-triangular-matrices" class="level3" data-number="B.2.1">
<h3 data-number="B.2.1" class="anchored" data-anchor-id="some-properties-of-triangular-matrices"><span class="header-section-number">B.2.1</span> Some properties of triangular matrices</h3>
<p>A triangular matrix with non-zero diagonal elements is non-singular. One way to show this is because its <a href="https://en.wikipedia.org/wiki/Determinant">determinant</a>, written <span class="math inline">\(\left|\mathbf{L}\right|\)</span>, which is the product of its diagonal elements, is non-zero. In the case of a Cholesky factor the determinant will be positive because all the diagonal elements are positive.</p>
<p>A more straightforward way of showing that such a matrix is non-singular is to show how a triangular system of equations, like <span id="eq-triangularsystem"><span class="math display">\[
\mathbf{Lx}=\mathbf{b}
\tag{B.9}\]</span></span> can be solved. In the case of a lower-triangular system the method is called <em>forward solution</em>, with the sequence of scalar equations <span id="eq-forwardsolve"><span class="math display">\[
\begin{aligned}
x_1&amp;=b_1/\mathbf{L}_{1,1}\\
x_2&amp;=\left(b_2-x_1\mathbf{L}_{2,1}\right)/\mathbf{L}_{2,2}\\
x_3&amp;=\left(b_3-x_1\mathbf{L}_{3,1}-x_2\mathbf{L}_{3,2}\right)/\mathbf{L}_{3,3}
\end{aligned}
\tag{B.10}\]</span></span> and so on.</p>
<p>One point to note here is that <span class="math inline">\(b_1\)</span> is not needed after <span class="math inline">\(x_1\)</span> is evaluated, <span class="math inline">\(b_2\)</span> is not needed after <span class="math inline">\(x_2\)</span> is evaluated, and so on. That is, the forward solution can be carried out <em>in place</em> by overwriting each element of <span class="math inline">\(\mathbf{b}\)</span> with the corresponding element of <span class="math inline">\({\mathbf{x}}\)</span>. This property is useful for avoiding allocation of storage in, for example, evaluation of an objective function during optimization.</p>
<p>The corresponding method of solving an upper-triangular system of equations is called <em>backward solution</em>, where <span class="math inline">\(b_n\)</span> is evaluated first, then <span class="math inline">\(b_{n-1}\)</span>, and so on.</p>
<p>Repeated forward solution (or backward solution for upper triangular) can be used to evaluate the inverse, <span class="math inline">\(\mathbf{L}^{-1}\)</span>, of a lower triangular matrix, <span class="math inline">\(\mathbf{L}\)</span>. However, a general rule in numerical linear algebra is that <a href="https://nhigham.com/2022/10/11/seven-sins-of-numerical-linear-algebra/">you rarely need to evaluate the full inverse of a matrix</a>. Solving a triangular system like <a href="#eq-triangularsystem" class="quarto-xref">Equation&nbsp;<span>B.9</span></a> by evaluating <span class="math inline">\(\mathbf{L}^{-1}\)</span> and forming the product <span id="eq-inversesolve"><span class="math display">\[
{\mathbf{x}}= \mathbf{L}^{-1}\mathbf{b}
\tag{B.11}\]</span></span> involves doing roughly <span class="math inline">\(n\)</span> times as much work as solving the system directly, as in <a href="#eq-forwardsolve" class="quarto-xref">Equation&nbsp;<span>B.10</span></a>. Requiring that the inverse of a matrix must be evaluated to solve a linear system is like saying that a quotient, <span class="math inline">\(a/b\)</span>, must be evalated by calculating <span class="math inline">\(b^{-1}\)</span>, the reciprocal of <span class="math inline">\(b\)</span>, then evaluating the product <span class="math inline">\(b^{-1}a\)</span>, instead of evaluating the quotient directly.</p>
<p>In a derivation we may write an expression like <span class="math inline">\(\mathbf{L}^{-1}\mathbf{b}\)</span> but the evaluation is performed by solving a system like <a href="#eq-forwardsolve" class="quarto-xref">Equation&nbsp;<span>B.10</span></a>.</p>
</section>
<section id="sec-cholesky" class="level3" data-number="B.2.2">
<h3 data-number="B.2.2" class="anchored" data-anchor-id="sec-cholesky"><span class="header-section-number">B.2.2</span> Positive definiteness and the Cholesky factor</h3>
<p>It turns out that the ability to form the Cholesky factor, which means that all the quantities like <span class="math inline">\({\boldsymbol{\Sigma}}_{2,2}-\mathbf{L}_{2,1}^2\)</span>, whose square roots form the diagonal of <span class="math inline">\(\mathbf{L}\)</span>, evaluate to positive numbers, is equivalent to <span class="math inline">\({\boldsymbol{\Sigma}}\)</span> being positive definite. It is straightforward to show that having a Cholesky factor implies that <span class="math inline">\({\boldsymbol{\Sigma}}\)</span> is positive definite, because <span id="eq-cholimpliesposdef"><span class="math display">\[
{\mathbf{x}}'{\boldsymbol{\Sigma}}{\mathbf{x}}= {\mathbf{x}}'{\mathbf{R}}'{\mathbf{R}}{\mathbf{x}}=\left(\mathbf{Rx}\right)'\mathbf{Rx}=\left\|\mathbf{Rx}\right\|^2
\tag{B.12}\]</span></span> where <span class="math inline">\(\left\|\mathbf{v}\right\|^2\)</span> is the squared length of the vector <span class="math inline">\(\mathbf{v}\)</span>. Because <span class="math inline">\({\mathbf{R}}\)</span> is non-singular, <span class="math inline">\({\mathbf{x}}\ne\mathbf{0}\implies\mathbf{Rx}\ne\mathbf{0}\)</span> and the squared length in <a href="#eq-cholimpliesposdef" class="quarto-xref">Equation&nbsp;<span>B.12</span></a> is greater than zero.</p>
<p>The other direction is a bit more complicated to prove but essentially it amounts to showing that if the process of generating the Cholesky factor requires the square root of a non-positive number to obtain a diagonal element then there is a direction in which the quadratic form gives a non-positive result.</p>
<p>In practice, the easiest way to check a symmetric matrix to see if it is positive definite is to attempt to evaluate the Cholesky factor and check whether that succeeds. This is exactly what the <code>isposdef</code> methods in the <code>LinearAlgebra</code> package do.</p>
</section>
<section id="sec-mvgaussian" class="level3" data-number="B.2.3">
<h3 data-number="B.2.3" class="anchored" data-anchor-id="sec-mvgaussian"><span class="header-section-number">B.2.3</span> Density of the multivariate Gaussian</h3>
<p>For the general multivariate normal distribution, <span class="math inline">\({\mathcal{N}}({\boldsymbol{\mu}},{\boldsymbol{\Sigma}})\)</span>, where <span class="math inline">\({\boldsymbol{\Sigma}}\)</span> is positive definite with lower Cholesky factor <span class="math inline">\(\mathbf{L}\)</span>, the probability density function is <span id="eq-mvndensity"><span class="math display">\[
\begin{aligned}
f({\mathbf{x}};{\boldsymbol{\mu}},{\boldsymbol{\Sigma}})&amp;=
\frac{1}{\sqrt{(2\pi)^n\left|{\boldsymbol{\Sigma}}\right|}}
\exp\left(\frac{-[{\mathbf{x}}-{\boldsymbol{\mu}}]'{\boldsymbol{\Sigma}}^{-1}[{\mathbf{x}}-{\boldsymbol{\mu}}]}{2}\right)\\
&amp;=\frac{1}{\sqrt{(2\pi)^n}\left|\mathbf{L}\right|}
\exp\left(\frac{-[{\mathbf{x}}-{\boldsymbol{\mu}}]'{\mathbf{L}'}^{-1}\mathbf{L}^{-1}[{\mathbf{x}}-{\boldsymbol{\mu}}]}{2}\right)\\
&amp;=\frac{1}{\sqrt{(2\pi)^n}\left|\mathbf{L}\right|}
\exp\left(\frac{-\left\|\mathbf{L}^{-1}[{\mathbf{x}}-{\boldsymbol{\mu}}]\right\|^2}{2}\right)\\
\end{aligned}
\tag{B.13}\]</span></span> and the standardizing transformation becomes <span id="eq-mvnstandardizing"><span class="math display">\[
\mathbf{z}=\mathbf{L}^{-1}[{\mathbf{x}}-{\boldsymbol{\mu}}] ,
\tag{B.14}\]</span></span> which, in practice, means using forward solution on the lower-triangular system of equations <span id="eq-mvnstandardizingsol"><span class="math display">\[
\mathbf{Lz}={\mathbf{x}}-{\boldsymbol{\mu}}.
\tag{B.15}\]</span></span></p>
<p>Note that the standardizing transformation gives us a way to simulate values from a general <span class="math inline">\(n\)</span>-dimensional multivariate Gaussian, <span class="math inline">\({\mathcal{X}}\sim{\mathcal{N}}({\boldsymbol{\mu}},{\boldsymbol{\Sigma}})\)</span> as <span id="eq-simulatemvn"><span class="math display">\[
{\mathbf{x}}={\boldsymbol{\mu}}+\mathbf{L}\mathbf{z}
\tag{B.16}\]</span></span> where <span class="math inline">\(\mathbf{z}\)</span> is simulated from the <span class="math inline">\(n\)</span>-dimensional <em>standard multivariate Gaussian</em>, <span class="math inline">\({\mathcal{Z}}\sim{\mathcal{N}}(\mathbf{0},{\mathbf{I}})\)</span>, which is <span class="math inline">\(n\)</span> independent univariate standard normal distributions.</p>
</section>
<section id="linear-functions-of-a-multivariate-gaussian" class="level3" data-number="B.2.4">
<h3 data-number="B.2.4" class="anchored" data-anchor-id="linear-functions-of-a-multivariate-gaussian"><span class="header-section-number">B.2.4</span> Linear functions of a multivariate Gaussian</h3>
In general, if <span class="math inline">\({\mathcal{X}}\)</span> is an <span class="math inline">\(n\)</span>-dimensional random variable with mean <span class="math inline">\({\boldsymbol{\mu}}\)</span> and covariance matrix <span class="math inline">\({\boldsymbol{\Sigma}}\)</span>, and <span class="math inline">\(\mathbf{A}\)</span> is a matrix with <span class="math inline">\(n\)</span> columns then the mean and variance of <span class="math inline">\({\mathcal{U}}=\mathbf{A}{\mathcal{X}}\)</span> are given by <span id="eq-mvexpectedlin"><span class="math display">\[
\require{unicode}
𝔼\left[{\mathcal{U}}\right] =
\mathbf{A}{\boldsymbol{\mu}}\quad\textrm{and}\quad \text{Var}\left({\mathcal{U}}\right) = \mathbf{A}{\boldsymbol{\Sigma}}\mathbf{A}'.
\tag{B.17}\]</span></span>
<details>
<summary>
Proof
</summary>
For the expectation: <span class="math display">\[
  \require{unicode}
𝔼\left[{\mathcal{U}}\right] =
𝔼\left[\mathbf{A}{\mathcal{X}}\right] =
\mathbf{A}𝔼\left[{\mathcal{X}}\right] =
\mathbf{A}{\boldsymbol{\mu}}.
\]</span> For the variance: <span class="math display">\[
\begin{aligned}
\text{Var}\left({\mathcal{U}}\right)
&amp;=𝔼\left[\left({\mathcal{U}}-𝔼\left[{\mathcal{U}}\right]\right)\left({\mathcal{U}}-𝔼\left[{\mathcal{U}}\right]\right)'\right]\\
&amp;=𝔼\left[\left(\mathbf{A}{\mathcal{X}}-\mathbf{A}{\boldsymbol{\mu}}\right)\left(\mathbf{A}{\mathcal{X}}-\mathbf{A}{\boldsymbol{\mu}}\right)'\right]\\
&amp;=𝔼\left[\mathbf{A}\left({\mathcal{X}}-{\boldsymbol{\mu}}\right)\left({\mathcal{X}}-{\boldsymbol{\mu}}\right)'\mathbf{A}'\right]\\
&amp;=\mathbf{A}\,𝔼\left[\left({\mathcal{X}}-{\boldsymbol{\mu}}\right)\left({\mathcal{X}}-{\boldsymbol{\mu}}\right)'\right]\mathbf{A}'\\
&amp;=\mathbf{A}\text{Var}({\mathcal{X}})\mathbf{A}'\\
&amp;=\mathbf{A}{\boldsymbol{\Sigma}}\mathbf{A}'.
\end{aligned}
\]</span>
</details>
<p>A linear function, <span class="math inline">\({\mathcal{U}}=\mathbf{A}{\mathcal{X}}\)</span>, of a multivariate Gaussian distribution, <span class="math inline">\({\mathcal{X}}\sim{\mathcal{N}}({\boldsymbol{\mu}},{\boldsymbol{\Sigma}})\)</span>, <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Affine_transformation">is also Gaussian</a> which implies: <span id="eq-mvnlinfunc"><span class="math display">\[
{\mathcal{U}}\sim{\mathcal{N}}(\mathbf{A}{\boldsymbol{\mu}}, \mathbf{A}{\boldsymbol{\Sigma}}\mathbf{A}')
\tag{B.18}\]</span></span></p>
<p>For the special case of <span class="math inline">\(\mathbf{A}\)</span> being of dimension <span class="math inline">\(1\times n\)</span> (i.e.&nbsp;a <em>row vector</em>), the expression for the <span class="math inline">\(1\times 1\)</span> covariance matrix is the quadratic form defined by <span class="math inline">\({\boldsymbol{\Sigma}}\)</span>, which is why <span class="math inline">\({\boldsymbol{\Sigma}}\)</span> must be positive definite for the conditional distributions to be non-degenerate.</p>
</section>
</section>
<section id="back-to-the-linear-model" class="level2" data-number="B.3">
<h2 data-number="B.3" class="anchored" data-anchor-id="back-to-the-linear-model"><span class="header-section-number">B.3</span> Back to the linear model</h2>
<p>The probability density function for the linear model, <a href="#eq-mvnlinmod" class="quarto-xref">Equation&nbsp;<span>B.2</span></a>, is <span id="eq-linmoddensity"><span class="math display">\[
\begin{aligned}
f({\mathbf{y}}; {\boldsymbol{\beta}}, \sigma^2)&amp;=
\frac{1}{\sqrt{2\pi\left|\sigma^2{\mathbf{I}}\right|}}
\exp\left(\frac{-[{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}]'
\left(\sigma^2{\mathbf{I}}\right)^{-1}[{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}]}{2}\right)\\
&amp;=\left(2\pi\sigma^2\right)^{-n/2}\exp\left(-\left\|{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}\right\|^2/\left(2\sigma^2\right)\right)
\end{aligned}
\tag{B.19}\]</span></span></p>
<p><a href="#eq-linmoddensity" class="quarto-xref">Equation&nbsp;<span>B.19</span></a> describes the density of the random variable, <span class="math inline">\({\mathcal{Y}}\)</span>, representing the observations, given the values of the parameters, <span class="math inline">\({\boldsymbol{\beta}}\)</span> and <span class="math inline">\(\sigma^2\)</span>. For parameter estimation we use the <em>likelihood function</em>, which is the same expression as <a href="#eq-linmoddensity" class="quarto-xref">Equation&nbsp;<span>B.19</span></a> but regarded as a function of the parameters, <span class="math inline">\({\boldsymbol{\beta}}\)</span> and <span class="math inline">\(\sigma^2\)</span>, with the observed response, <span class="math inline">\({\mathbf{y}}\)</span>, fixed. <span id="eq-linmodlikelihood"><span class="math display">\[
L({\boldsymbol{\beta}},\sigma^2;{\mathbf{y}})=
\left(2\pi\sigma^2\right)^{-n/2}\exp\left(-\left\|{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}\right\|^2/\left(2\sigma^2\right)\right)
\tag{B.20}\]</span></span> The <a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation">maximum likelihood</a> estimates of the parameters are, as the name implies, the values of <span class="math inline">\({\boldsymbol{\beta}}\)</span> and <span class="math inline">\(\sigma^2\)</span> that maximize the expression on the right of <a href="#eq-linmodlikelihood" class="quarto-xref">Equation&nbsp;<span>B.20</span></a> .</p>
<p>Because the logarithm is a <a href="https://en.wikipedia.org/wiki/Monotonic_function">monotone increasing</a> function, the maximum likelihood estimates will also maximize the <em>log-likelihood</em> <span id="eq-linmodloglike"><span class="math display">\[
\begin{aligned}
\ell({\boldsymbol{\beta}},\sigma^2;{\mathbf{y}})
&amp;=\log L({\boldsymbol{\beta}},\sigma^2;{\mathbf{y}})\\
&amp;=-\frac{n}{2}\log(2\pi\sigma^2)-\frac{\left\|{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}\right\|^2}{2\sigma^2}
\end{aligned}
\tag{B.21}\]</span></span> Usually the log-likelihood is easier to optimize, either algebraically or numerically, than the likelihood itself.</p>
<p>To avoid the negative signs and the factors of 2 in the denominator, we often convert the log-likelihood to the <em>deviance scale</em>, which is negative twice the log-likelihood, <span id="eq-linmoddevscale"><span class="math display">\[
\begin{aligned}
d({\boldsymbol{\beta}},\sigma^2;{\mathbf{y}})
&amp;=-2\ell({\boldsymbol{\beta}},\sigma^2; {\mathbf{y}})\\
&amp;=n\log(2\pi\sigma^2)+\frac{\left\|{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}\right\|^2}{\sigma^2} .
\end{aligned}
\tag{B.22}\]</span></span> Because of the negative sign, the maximum likelihood estimates are those that <em>minimize</em> <span class="math inline">\(d({\boldsymbol{\beta}},\sigma^2;{\mathbf{y}})\)</span>.</p>
<p>(The term <em>deviance scale</em> is used for <span class="math inline">\(d({\boldsymbol{\beta}},\sigma^2;{\mathbf{y}})\)</span> rather than <a href="https://en.wikipedia.org/wiki/Deviance_(statistics)">deviance</a> because the deviance involves an additive shift, which is a correction for the saturated model - see the link. It is obvious what the saturated model should be for the linear model but not for the linear mixed model so, to avoid confusion, we refer to the log-likelihood on the deviance scale as the <em>objective</em>.)</p>
<p>The form of <a href="#eq-linmoddevscale" class="quarto-xref">Equation&nbsp;<span>B.22</span></a> makes it easy to determine the maximum likelihood estimates. Because <span class="math inline">\({\boldsymbol{\beta}}\)</span> appears only in the sum of squared residuals expression, <span class="math inline">\(\|{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}\|^2\)</span>, we minimize that with respect to <span class="math inline">\({\boldsymbol{\beta}}\)</span> <span id="eq-leastsquaresest"><span class="math display">\[
\widehat{{\boldsymbol{\beta}}}=
\arg\min_{{\boldsymbol{\beta}}}\|{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}\|^2 ,
\tag{B.23}\]</span></span> where <span class="math inline">\(\arg\min_{{\boldsymbol{\beta}}}\)</span> means the value of <span class="math inline">\({\boldsymbol{\beta}}\)</span> that minimizes the expression that follows.</p>
<p>Let <span class="math inline">\(r^2(\widehat{{\boldsymbol{\beta}}}) = \left\|{\mathbf{y}}-{\mathbf{X}}\widehat{{\boldsymbol{\beta}}}\right\|^2\)</span> be the minimum sum of squared residuals. Substituting this value into <a href="#eq-linmoddevscale" class="quarto-xref">Equation&nbsp;<span>B.22</span></a>, differentiating with respect to <span class="math inline">\(\sigma^2\)</span>, and setting this derivative to zero gives <span class="math display">\[
\widehat{\sigma^2}=\frac{r^2(\widehat{{\boldsymbol{\beta}}})}{n} .
\]</span></p>
</section>
<section id="minimizing-the-sum-of-squared-residuals" class="level2" data-number="B.4">
<h2 data-number="B.4" class="anchored" data-anchor-id="minimizing-the-sum-of-squared-residuals"><span class="header-section-number">B.4</span> Minimizing the sum of squared residuals</h2>
<p>A condition for <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span> to minimize the sum of squared residuals is that the <em>gradient</em> <span id="eq-sumsqgrad"><span class="math display">\[
\nabla r^2({\boldsymbol{\beta}})=-2{\mathbf{X}}'({\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}})
\tag{B.24}\]</span></span> be zero at <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span>. This condition can be rewritten as <span id="eq-normaleq"><span class="math display">\[
{\mathbf{X}}'{\mathbf{X}}\widehat{{\boldsymbol{\beta}}}={\mathbf{X}}'{\mathbf{y}},
\tag{B.25}\]</span></span> which are called the <em>normal equations</em>.</p>
<p>The term <em>normal</em> in this expression comes from the fact that requiring the gradient, <a href="#eq-sumsqgrad" class="quarto-xref">Equation&nbsp;<span>B.24</span></a>, to be zero is equivalent to requiring that the <em>residual vector</em>, <span class="math inline">\({\mathbf{y}}-{\mathbf{X}}\widehat{{\boldsymbol{\beta}}}\)</span>, be perpendicular, or <em>normal</em>, to the columns of <span class="math inline">\({\mathbf{X}}\)</span>.</p>
<p>When the model matrix, <span class="math inline">\({\mathbf{X}}\)</span>, is of <em>full column rank</em>, which means <span id="eq-fullcolumnrank"><span class="math display">\[
{\mathbf{X}}\mathbf{{\boldsymbol{\beta}}}\ne\mathbf{0}\quad\forall{\boldsymbol{\beta}}\ne\mathbf{0} ,
\tag{B.26}\]</span></span> then the quadratic form defined by <span class="math inline">\({\mathbf{X}}'{\mathbf{X}}\)</span> is positive definite and has a Cholesky factor, say <span class="math inline">\({\mathbf{R}}_{XX}\)</span>, and the normal equations can be solved in two stages. First, solve <span id="eq-rXydef"><span class="math display">\[
{\mathbf{R}}_{XX}'\mathbf{r}_{Xy}={\mathbf{X}}'{\mathbf{y}}
\tag{B.27}\]</span></span> for <span class="math inline">\(\mathbf{r}_{Xy}\)</span> using forward solution, then solve <span id="eq-betahatchol"><span class="math display">\[
{\mathbf{R}}_{XX}\widehat{{\boldsymbol{\beta}}}=\mathbf{r}_{Xy}
\tag{B.28}\]</span></span> for <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span> using backward solution.</p>
<p>An alternative approach is to write the residual sum of squares as a quadratic form <span id="eq-extendedqf"><span class="math display">\[
\begin{aligned}
r^2({\boldsymbol{\beta}})&amp;=\|{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}\|^2\\
&amp;=({\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}})'({\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}})\\
&amp;=({\mathbf{X}}{\boldsymbol{\beta}}-{\mathbf{y}})'({\mathbf{X}}{\boldsymbol{\beta}}-{\mathbf{y}})\\
&amp;=\begin{bmatrix}{\boldsymbol{\beta}}&amp;-1\end{bmatrix}
\begin{bmatrix}
{\mathbf{X}}'{\mathbf{X}}&amp; {\mathbf{X}}'{\mathbf{y}}\\
{\mathbf{y}}'{\mathbf{X}}&amp; {\mathbf{y}}'{\mathbf{y}}
\end{bmatrix}
\begin{bmatrix}
{\boldsymbol{\beta}}\\
-1
\end{bmatrix}\\
&amp;=\begin{bmatrix}{\boldsymbol{\beta}}&amp;-1\end{bmatrix}
\begin{bmatrix}
{\mathbf{R}}_{XX}' &amp; \mathbf{0}\\
\mathbf{r}_{Xy}' &amp; r_{yy}
\end{bmatrix}
\begin{bmatrix}
{\mathbf{R}}_{XX} &amp; \mathbf{r}_{Xy}\\
\mathbf{0} &amp; r_{yy}
\end{bmatrix}
\begin{bmatrix}
{\boldsymbol{\beta}}\\
-1
\end{bmatrix}\\
&amp;=\left\|
\begin{bmatrix}
{\mathbf{R}}_{XX} &amp; \mathbf{r}_{Xy}\\
\mathbf{0} &amp; r_{yy}
\end{bmatrix}
\begin{bmatrix}
{\boldsymbol{\beta}}\\
-1
\end{bmatrix}\right\|^2\\
&amp;=\left\|{\mathbf{R}}_{XX}{\boldsymbol{\beta}}-\mathbf{r}_{Xy}\right\|^2+r_{yy}^2
\end{aligned}
\tag{B.29}\]</span></span></p>
<p>The first term, <span class="math inline">\(\left\|{\mathbf{R}}_{XX}{\boldsymbol{\beta}}-\mathbf{r}_{Xy}\right\|^2\)</span>, is non-negative and can be made zero by solving <a href="#eq-betahatchol" class="quarto-xref">Equation&nbsp;<span>B.28</span></a> for <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span>. Thus, the minimum sum of squared residuals is <span class="math inline">\(r_{yy}^2\)</span>.</p>
<p>One consequence of this derivation is that the minimum sum of squared residuals can be evaluated directly from the extended Cholesky factor <span id="eq-extendedcholfac"><span class="math display">\[
\begin{bmatrix}
{\mathbf{R}}_{XX} &amp; \mathbf{r}_{Xy}\\
\mathbf{0} &amp; r_{yy}
\end{bmatrix}
\tag{B.30}\]</span></span> without needing to solve for <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span> first. This is not terribly important for a linear model where the evaluation of <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span> and the residual is typically done only once. However, for the linear mixed model, a similar calculation must be done for every evaluation of the objective in the iterative optimization, and being able to evaluate the minimum penalized sum of squared residuals without solving for parameter values and without needing to evaluate the residual saves a non-negligible amount of time and effort.</p>
</section>
<section id="numerical-example" class="level2" data-number="B.5">
<h2 data-number="B.5" class="anchored" data-anchor-id="numerical-example"><span class="header-section-number">B.5</span> Numerical example</h2>
<p>Suppose we wish to fit a simple linear regression model to the reaction time as a function of days of sleep deprivation to the data from subject <code>S372</code> in the <code>sleepstudy</code> dataset.</p>
<div id="4" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>sleepstudy <span class="op">=</span> <span class="fu">Table</span>(<span class="fu">dataset</span>(<span class="op">:</span>sleepstudy))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>S372 <span class="op">=</span> sleepstudy[sleepstudy.subj <span class="op">.==</span> <span class="st">"S372"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>Table with 3 columns and 10 rows:
      subj  days  reaction
    ┌─────────────────────
 1  │ S372  0     269.412
 2  │ S372  1     273.474
 3  │ S372  2     297.597
 4  │ S372  3     310.632
 5  │ S372  4     287.173
 6  │ S372  5     329.608
 7  │ S372  6     334.482
 8  │ S372  7     343.22
 9  │ S372  8     369.142
 10 │ S372  9     364.124</code></pre>
</div>
</div>
<p>The model matrix and the response vector can be constructed as</p>
<div id="6" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="fu">hcat</span>(<span class="fu">ones</span>(<span class="fu">length</span>(S372)), S372.days)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>10×2 Matrix{Float64}:
 1.0  0.0
 1.0  1.0
 1.0  2.0
 1.0  3.0
 1.0  4.0
 1.0  5.0
 1.0  6.0
 1.0  7.0
 1.0  8.0
 1.0  9.0</code></pre>
</div>
</div>
<p>and</p>
<div id="8" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> S372.reaction</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">show</span>(y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[269.4117, 273.474, 297.5968, 310.6316, 287.1726, 329.6076, 334.4818, 343.2199, 369.1417, 364.1236]</code></pre>
</div>
</div>
<p>from which we obtain the Cholesky factor</p>
<div id="10" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>chfac <span class="op">=</span> <span class="fu">cholesky!</span>(X<span class="op">'</span>X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>Cholesky{Float64, Matrix{Float64}}
U factor:
2×2 UpperTriangular{Float64, Matrix{Float64}}:
 3.16228  14.2302
  ⋅        9.08295</code></pre>
</div>
</div>
<p>(Recall that the upper triangular Cholesky factor is the <code>U</code> property of the <code>Cholesky</code> type.)</p>
<p>The <code>\</code> operator with a <code>Cholesky</code> factor on the left performs both the forward and backward solutions to obtain the least squares estimates</p>
<div id="12" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>β̂ <span class="op">=</span> chfac <span class="op">\</span> (X<span class="op">'</span>y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>2-element Vector{Float64}:
 267.04479999999995
  11.298073333333345</code></pre>
</div>
</div>
<p>Alternatively, we could carry out the two solutions of the triangular systems explicitly by first solving for <span class="math inline">\(\mathbf{r}_{Xy}\)</span></p>
<div id="14" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>rXy <span class="op">=</span> <span class="fu">ldiv!</span>(chfac.L, X<span class="op">'</span>y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>2-element Vector{Float64}:
 1005.244207376381
  102.61984718485859</code></pre>
</div>
</div>
<p>then solving in-place to obtain <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span></p>
<div id="16" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ldiv!</span>(chfac.U, rXy)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>2-element Vector{Float64}:
 267.0447999999998
  11.298073333333367</code></pre>
</div>
</div>
<p>The residual vector, <span class="math inline">\({\mathbf{y}}-{\mathbf{X}}\widehat{{\boldsymbol{\beta}}}\)</span>, is</p>
<div id="18" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> y <span class="op">-</span> X <span class="op">*</span> β̂</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>10-element Vector{Float64}:
   2.3669000000000437
  -4.868873333333283
   7.955853333333323
   9.69258000000002
 -25.06449333333336
   6.072433333333322
  -0.35144000000002507
  -2.911413333333371
  11.712313333333327
  -4.603860000000054</code></pre>
</div>
</div>
<p>with geometric length or “norm”,</p>
<div id="20" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">norm</span>(r)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>31.915932906580302</code></pre>
</div>
</div>
<p>For the extended Cholesky factor, create the extended matrix of sums of squares and cross products</p>
<div id="22" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>crprod <span class="op">=</span> <span class="kw">let</span> x <span class="op">=</span> S372.days</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">Symmetric</span>(</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    [</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">length</span>(x) <span class="fu">sum</span>(x) <span class="fu">sum</span>(y)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>      <span class="fl">0.0</span> <span class="fu">sum</span>(abs2, x) <span class="fu">dot</span>(x, y)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>      <span class="fl">0.0</span> <span class="fl">0.0</span> <span class="fu">sum</span>(abs2, y)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>U,</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>3×3 Symmetric{Float64, Matrix{Float64}}:
   10.0      45.0   3178.86
   45.0     285.0  15237.0
 3178.86  15237.0      1.02207e6</code></pre>
</div>
</div>
<p>The call to <code>Symmetric</code> with the second argument the symbol <code>:U</code> indicates that the matrix should be treated as symmetric but only the upper triangle is given.</p>
<p>The Cholesky factor of the <code>crprod</code> reproduces <span class="math inline">\({\mathbf{R}}_{XX}\)</span>, <span class="math inline">\(\mathbf{r}_{Xy}\)</span>, and the norm of the residual, <span class="math inline">\(r_{yy}\)</span>.</p>
<div id="24" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>extchfac <span class="op">=</span> <span class="fu">cholesky</span>(crprod)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>Cholesky{Float64, Matrix{Float64}}
U factor:
3×3 UpperTriangular{Float64, Matrix{Float64}}:
 3.16228  14.2302   1005.24
  ⋅        9.08295   102.62
  ⋅         ⋅         31.9159</code></pre>
</div>
</div>
<p>and information from which the parameter estimates can be evaluated.</p>
<div id="26" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>β̂ <span class="op">≈</span> <span class="fu">ldiv!</span>(</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">UpperTriangular</span>(<span class="fu">view</span>(extchfac.U, <span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">2</span>)),</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">copy</span>(<span class="fu">view</span>(extchfac.U, <span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, <span class="fl">3</span>)),</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>true</code></pre>
</div>
</div>
<p>The operator <code>≈</code> is a check of approximate equality of floating point numbers or arrays. Exact equality of floating point results from “equivalent” calculations cannot be relied upon.</p>
<p>Similarly we check that the value of <span class="math inline">\(r_{y,y}\)</span> is approximately equal to the norm of the residual vector.</p>
<div id="28" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">norm</span>(r) <span class="op">≈</span> extchfac.U[<span class="fl">3</span>, <span class="fl">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>true</code></pre>
</div>
</div>
</section>
<section id="sec-matrixdecomp" class="level2" data-number="B.6">
<h2 data-number="B.6" class="anchored" data-anchor-id="sec-matrixdecomp"><span class="header-section-number">B.6</span> Alternative decompositions of X</h2>
<p>There are two other decompositions of the model matrix <span class="math inline">\({\mathbf{X}}\)</span> or the augmented model matrix <span class="math inline">\([\mathbf{X,y}]\)</span> that can be used to evaluate the least squares estimates; the <a href="https://en.wikipedia.org/wiki/QR_decomposition">QR decomposition</a> and the <a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">singular value decomposition (SVD)</a>.</p>
<p>The QR decomposition expresses <span class="math inline">\({\mathbf{X}}\)</span> as the product of an <em>orthogonal</em> matrix, <span class="math inline">\(\mathbf{Q}\)</span>, and an upper triangular matrix <span class="math inline">\({\mathbf{R}}\)</span>. The upper triangular <span class="math inline">\({\mathbf{R}}\)</span> is related to the upper triangular Cholesky factor in that the numerical values are the same but the signs can be different. In particular, the usual way of creating <span class="math inline">\(\mathbf{Q}\)</span> and <span class="math inline">\({\mathbf{R}}\)</span> using <a href="https://en.wikipedia.org/wiki/Householder_transformation">Householder transformations</a> typically results in the first row of <span class="math inline">\({\mathbf{R}}\)</span> from the <code>qr</code> function being the negative of the first row of the upper Cholesky factor.</p>
<div id="30" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>qrfac <span class="op">=</span> <span class="fu">qr</span>(X)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>qrfac.R</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>2×2 Matrix{Float64}:
 -3.16228  -14.2302
  0.0        9.08295</code></pre>
</div>
</div>
<p>Just as the Cholesky factor can be used on the left of the <code>\</code> operator, so can the <code>qr</code> factor but with <code>y</code> on the right.</p>
<div id="32" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>b3 <span class="op">=</span> qrfac <span class="op">\</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>2-element Vector{Float64}:
 267.0447999999998
  11.298073333333361</code></pre>
</div>
</div>
<p>The matrix <span class="math inline">\({\mathbf{R}}\)</span> is returned as a square matrix with the same number of columns as <span class="math inline">\({\mathbf{X}}\)</span>. That is, if <span class="math inline">\({\mathbf{X}}\)</span> is of size <span class="math inline">\(n\times p\)</span> where <span class="math inline">\(n&gt;p\)</span>, as in the example, then <span class="math inline">\({\mathbf{R}}\)</span> is <span class="math inline">\(p\times p\)</span>, as shown above.</p>
<p>The matrix <span class="math inline">\(\mathbf{Q}\)</span> is usually considered to be an <span class="math inline">\(n\times n\)</span> orthogonal matrix, which means that its transpose is its inverse <span id="eq-orthogonalQ"><span class="math display">\[
\mathbf{Q'Q}=\mathbf{QQ'}={\mathbf{I}}
\tag{B.31}\]</span></span> To form the product <span class="math inline">\(\mathbf{QR}\)</span> the matrix <span class="math inline">\({\mathbf{R}}\)</span> is treated as if it were <span class="math inline">\(n\times p\)</span> with zeros below the main diagonal.</p>
<p>The <span class="math inline">\(n\times n\)</span> matrix <span class="math inline">\(\mathbf{Q}\)</span> can be very large if <span class="math inline">\(n\)</span>, the number of observations, is large but it does not need to be explicitly evaluated. In practice <span class="math inline">\(\mathbf{Q}\)</span> is a “virtual” matrix represented as a product of Householder reflections that only require storage of the size of <span class="math inline">\({\mathbf{X}}\)</span>. The effect of multiplying a vector or matrix by <span class="math inline">\(\mathbf{Q}\)</span> or by <span class="math inline">\(\mathbf{Q}'\)</span> is achieved by applying the Householder reflections in a particular order.</p>
<div id="34" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>rXy2 <span class="op">=</span> qrfac.Q<span class="op">'</span>y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>10-element Vector{Float64}:
 -1005.244207376381
   102.61984718485857
     8.057970700644944
     9.32194331578711
   -25.90788406907069
     4.75628854607146
    -2.140338838786306
    -5.1730662236441844
     8.977906391498038
    -7.8110209933598185</code></pre>
</div>
</div>
<div id="36" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>b4 <span class="op">=</span> <span class="fu">ldiv!</span>(<span class="fu">UpperTriangular</span>(qrfac.R), rXy2[<span class="fl">1</span><span class="op">:</span><span class="fl">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>2-element Vector{Float64}:
 267.0447999999998
  11.298073333333361</code></pre>
</div>
</div>
<p>Forming the QR decomposition is a direct, non-iterative, calculation, like forming the Cholesky factor. Forming the SVD, by contrast, is usually an iterative calculation. (It should be noted that modern methods for evaluating the SVD are very fast for an iterative calculation.) The SVD consists of two orthogonal matrices, the <span class="math inline">\(n\times n\)</span> <span class="math inline">\(\mathbf{U}\)</span> and the <span class="math inline">\(p\times p\)</span> <span class="math inline">\(\mathbf{V}\)</span> and an <span class="math inline">\(n\times p\)</span> matrix <span class="math inline">\(\mathbf{S}\)</span> that is zero off the main diagonal, where <span class="math display">\[
{\mathbf{X}}=\mathbf{USV'} .
\]</span></p>
<p>Unlike the <span class="math inline">\(\mathbf{Q}\)</span> in the QR decomposition, the orthogonal matrices <span class="math inline">\(\mathbf{U}\)</span> and <span class="math inline">\(\mathbf{V}\)</span> are explicitly evaluated. Because of this, the default for the <code>svd</code> function is to produce a compact form where <span class="math inline">\(\mathbf{U}\)</span> is <span class="math inline">\(n\times p\)</span> and only the diagonal of <span class="math inline">\(\mathbf{S}\)</span> is returned.</p>
<div id="38" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>Xsvd <span class="op">=</span> <span class="fu">svd</span>(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>SVD{Float64, Float64, Matrix{Float64}, Vector{Float64}}
U factor:
10×2 Matrix{Float64}:
 0.00921331   0.587682
 0.0669862    0.493961
 0.124759     0.400241
 0.182532     0.306521
 0.240305     0.2128
 0.298078     0.11908
 0.355851     0.0253594
 0.413623    -0.068361
 0.471396    -0.162081
 0.529169    -0.255802
singular values:
2-element Vector{Float64}:
 17.093167142525193
  1.680368125649001
Vt factor:
2×2 Matrix{Float64}:
 0.157485   0.987521
 0.987521  -0.157485</code></pre>
</div>
</div>
<p>(In general, the <code>Vt factor</code> from this decomposition is <span class="math inline">\(\mathbf{V}'\)</span>, the transpose of <span class="math inline">\(\mathbf{V}\)</span>. The distinction is not important in this case because <span class="math inline">\(\mathbf{V}\)</span> is symmetric. )</p>
<p>If all the singular values are non-zero, as is the case here, the least squares solution <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span> can be obtained as</p>
<p><span id="eq-pseudoinv"><span class="math display">\[
\mathbf{V}\mathbf{S}^{-1}\mathbf{U}'{\mathbf{y}}
\tag{B.32}\]</span></span></p>
<p>for the diagonal <span class="math inline">\(\mathbf{S}\)</span>.</p>
<div id="40" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>b5 <span class="op">=</span> Xsvd.V <span class="op">*</span> (Xsvd.U<span class="op">'</span>y <span class="op">./</span> Xsvd.S)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>2-element Vector{Float64}:
 267.04479999999995
  11.29807333333336</code></pre>
</div>
</div>
<p>In the extensions to linear mixed-effects models we will emphasize the Cholesky factorization over the QR decomposition or the SVD.</p>
</section>
<section id="sec-lmmtheory" class="level2" data-number="B.7">
<h2 data-number="B.7" class="anchored" data-anchor-id="sec-lmmtheory"><span class="header-section-number">B.7</span> Linear mixed-effects models</h2>
<p>As described in <span class="citation" data-cites="bates.maechler.etal:2015">Bates et al. (<a href="references.html#ref-bates.maechler.etal:2015" role="doc-biblioref">2015</a>)</span> , a linear mixed-effects model is based on two vector-valued random variables: the <span class="math inline">\(q\)</span>-dimensional vector of random effects, <span class="math inline">\({\mathcal{B}}\)</span>, and the <span class="math inline">\(n\)</span>-dimensional response vector, <span class="math inline">\({\mathcal{Y}}\)</span>. <a href="intro.html#eq-lmmdist" class="quarto-xref">Equation&nbsp;<span>1.2</span></a> defines the unconditional distribution of <span class="math inline">\({\mathcal{B}}\)</span> and the conditional distribution of <span class="math inline">\({\mathcal{Y}}\)</span>, given <span class="math inline">\({\mathcal{B}}=\mathbf{b}\)</span>, as multivariate Gaussian distributions of the form <span class="math display">\[
\begin{aligned}
({\mathcal{Y}}|{\mathcal{B}}=\mathbf{b})&amp;\sim{\mathcal{N}}({\mathbf{X}}{\boldsymbol{\beta}}+\mathbf{Z}\mathbf{b},\sigma^2{\mathbf{I}})\\
{\mathcal{B}}&amp;\sim{\mathcal{N}}(\mathbf{0},{\boldsymbol{\Sigma}}_\theta) .
\end{aligned}
\]</span></p>
<p>The <span class="math inline">\(q\times q\)</span>, symmetric, variance-covariance matrix, <span class="math inline">\(\mathrm{Var}({\mathcal{B}})={\boldsymbol{\Sigma}}_\theta\)</span>, depends on the <em>variance-component parameter vector</em>, <span class="math inline">\({\boldsymbol{\theta}}\)</span>, through a lower triangular <em>relative covariance factor</em>, <span class="math inline">\({\boldsymbol{\Lambda}}_\theta\)</span>, as</p>
<p><span id="eq-relcovfac"><span class="math display">\[
{\boldsymbol{\Sigma}}_\theta=\sigma^2{\boldsymbol{\Lambda}}_\theta{\boldsymbol{\Lambda}}_\theta' .
\tag{B.33}\]</span></span></p>
<p>(Recall that the lower Cholesky factor is generally written <span class="math inline">\(\mathbf{L}\)</span>. In this case the lower Cholesky factor contains parameters and is named with the corresponding Greek letter, <span class="math inline">\({\boldsymbol{\Lambda}}\)</span>.)</p>
<p>In many descriptions of linear mixed models, computational formulas are written in terms of the <em>precision matrix</em>, <span class="math inline">\({\boldsymbol{\Sigma}}_\theta^{-1}\)</span>. Such formulas will become unstable as <span class="math inline">\({\boldsymbol{\Sigma}}_\theta\)</span> approaches singularity. And it can do so. It is a fact that singular (i.e.&nbsp;non-invertible) <span class="math inline">\({\boldsymbol{\Sigma}}_\theta\)</span> can and do occur in practice, as we have seen in some of the examples in earlier chapters. Moreover, during the course of the numerical optimization by which the parameter estimates are determined, it is frequently the case that the deviance or the REML criterion will need to be evaluated at values of <span class="math inline">\({\boldsymbol{\theta}}\)</span> that produce a singular <span class="math inline">\({\boldsymbol{\Sigma}}_\theta\)</span>. Because of this we will take care to use computational methods that can be applied even when <span class="math inline">\({\boldsymbol{\Sigma}}_\theta\)</span> is singular and are stable as <span class="math inline">\({\boldsymbol{\Sigma}}_\theta\)</span> approaches singularity.</p>
<p>According to <a href="#eq-relcovfac" class="quarto-xref">Equation&nbsp;<span>B.33</span></a>, <span class="math inline">\({\boldsymbol{\Sigma}}\)</span> depends on both <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(\theta\)</span>, and we should write it as <span class="math inline">\({\boldsymbol{\Sigma}}_{\sigma,\theta}\)</span>. However, we will blur that distinction and continue to write <span class="math inline">\(\text{Var}({\mathcal{B}})={\boldsymbol{\Sigma}}_\theta\)</span>.</p>
<p>Another technicality is that the <em>common scale parameter</em>, <span class="math inline">\(\sigma\)</span>, could, in theory, be zero. However, the only way for its estimate, <span class="math inline">\(\widehat{\sigma}\)</span>, to be zero is for the fitted values from the fixed-effects only, <span class="math inline">\({\mathbf{X}}\widehat{{\boldsymbol{\beta}}}\)</span>, to be exactly equal to the observed data. This occurs only with data that have been (incorrectly) simulated without error. In practice we can safely assume that <span class="math inline">\(\sigma&gt;0\)</span>. However, <span class="math inline">\({\boldsymbol{\Lambda}}_\theta\)</span>, like <span class="math inline">\({\boldsymbol{\Sigma}}_\theta\)</span>, can be singular.</p>
<p>The computational methods in the <em>MixedModels</em> package are based on <span class="math inline">\({\boldsymbol{\Lambda}}_\theta\)</span> and do not require evaluation of <span class="math inline">\({\boldsymbol{\Sigma}}_\theta\)</span>. In fact, <span class="math inline">\({\boldsymbol{\Sigma}}_\theta\)</span> is explicitly evaluated only at the converged parameter estimates.</p>
<p>The spherical random effects, <span class="math inline">\({\mathcal{U}}\sim{\mathcal{N}}(\mathbf{0},\sigma^2{\mathbf{I}}_q)\)</span>, determine <span class="math inline">\({\mathcal{B}}\)</span> as</p>
<p><span id="eq-sphericalre"><span class="math display">\[
{\mathcal{B}}={\boldsymbol{\Lambda}}_\theta{\mathcal{U}}.
\tag{B.34}\]</span></span></p>
<p>Although it may seem more intuitive to write <span class="math inline">\({\mathcal{U}}\)</span> as a linear transformation of <span class="math inline">\({\mathcal{B}}\)</span>, we cannot do that when <span class="math inline">\({\boldsymbol{\Lambda}}_\theta\)</span> is singular, which is why <a href="#eq-sphericalre" class="quarto-xref">Equation&nbsp;<span>B.34</span></a> is in the form shown.</p>
<p>We can easily verify that <a href="#eq-sphericalre" class="quarto-xref">Equation&nbsp;<span>B.34</span></a> provides the desired distribution for <span class="math inline">\({\mathcal{B}}\)</span>. As a linear transformation of a multivariate Gaussian random variable, <span class="math inline">\({\mathcal{B}}\)</span> will also be multivariate Gaussian with mean</p>
<p><span class="math display">\[
𝔼\left[{\mathcal{B}}\right]=
𝔼\left[{\boldsymbol{\Lambda}}_\theta{\mathcal{U}}\right]=
{\boldsymbol{\Lambda}}_\theta\,𝔼\left[{\mathcal{U}}\right]=
{\boldsymbol{\Lambda}}_\theta\mathbf{0}=\mathbf{0}
\]</span></p>
<p>and covariance matrix</p>
<p><span class="math display">\[
\text{Var}({\mathcal{B}})=
{\boldsymbol{\Lambda}}_\theta\text{Var}({\mathcal{U}}){\boldsymbol{\Lambda}}_\theta'=
\sigma^2{\boldsymbol{\Lambda}}_\theta{\boldsymbol{\Lambda}}_\theta'={\boldsymbol{\Sigma}}_\theta
\]</span></p>
<p>Just as we concentrate on how <span class="math inline">\({\boldsymbol{\theta}}\)</span> determines <span class="math inline">\({\boldsymbol{\Lambda}}_\theta\)</span>, not <span class="math inline">\({\boldsymbol{\Sigma}}_\theta\)</span>, we will concentrate on properties of <span class="math inline">\({\mathcal{U}}\)</span> rather than <span class="math inline">\({\mathcal{B}}\)</span>. In particular, we now define the model according to the distributions</p>
<p><span id="eq-condygivenu"><span class="math display">\[
\begin{aligned}
({\mathcal{Y}}|{\mathcal{U}}=\mathbf{u})&amp;\sim{\mathcal{N}}(\mathbf{Z}{\boldsymbol{\Lambda}}_\theta\mathbf{u}+{\mathbf{X}}\beta,\sigma^2{\mathbf{I}}_n)\\
{\mathcal{U}}&amp;\sim{\mathcal{N}}(\mathbf{0},\sigma^2{\mathbf{I}}_q) .
\end{aligned}
\tag{B.35}\]</span></span></p>
<p>The joint density for <span class="math inline">\({\mathcal{Y}}\)</span> and <span class="math inline">\({\mathcal{U}}\)</span> is the product of densities of the two distributions in <a href="#eq-condygivenu" class="quarto-xref">Equation&nbsp;<span>B.35</span></a>. That is</p>
<p><span id="eq-yujointdensity"><span class="math display">\[
f_{{\mathcal{Y}},{\mathcal{U}}}({\mathbf{y}},\mathbf{u})=
\frac{1}{\left(2\pi\sigma^2\right)^{(n+q)/2}}\exp
\left(\frac{\left\|{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}
-\mathbf{Z}{\boldsymbol{\Lambda}}_\theta\mathbf{u}\right\|^2+
\left\|\mathbf{u}\right\|^2}{-2\sigma^2}\right) .
\tag{B.36}\]</span></span></p>
<p>To evaluate the likelihood for the parameters, <span class="math inline">\({\boldsymbol{\theta}}\)</span>, <span class="math inline">\({\boldsymbol{\beta}}\)</span>, and <span class="math inline">\(\sigma^2\)</span>, given the observed response, <span class="math inline">\({\mathbf{y}}\)</span>, we must evaluate the marginal distribution of <span class="math inline">\({\mathcal{Y}}\)</span>, which is the integral of <span class="math inline">\(f_{{\mathcal{Y}},{\mathcal{U}}}({\mathbf{y}},\mathbf{u})\)</span> with respect to <span class="math inline">\(\mathbf{u}\)</span>.</p>
<p>This is much simpler if we rewrite the <em>penalized sum of squared residuals</em>, <span class="math inline">\(\left\|{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}
-\mathbf{Z}{\boldsymbol{\Lambda}}_\theta\mathbf{u}\right\|^2+
\left\|\mathbf{u}\right\|^2\)</span>, from <a href="#eq-yujointdensity" class="quarto-xref">Equation&nbsp;<span>B.36</span></a>, as a quadratic form in <span class="math inline">\(\mathbf{u}\)</span>, to isolate the dependence on <span class="math inline">\(\mathbf{u}\)</span></p>
<p><span id="eq-penalized-rss"><span class="math display">\[
\begin{aligned}
r^2_\theta(\mathbf{u},{\boldsymbol{\beta}})
&amp;=
\|{\mathbf{y}}-{\mathbf{X}}{\boldsymbol{\beta}}-\mathbf{Z}{\boldsymbol{\Lambda}}_\theta\mathbf{u}\|^2+\|\mathbf{u}\|^2 \\
&amp;=
\left\|
\begin{bmatrix}
\mathbf{Z}{\boldsymbol{\Lambda}}_\theta &amp; {\mathbf{X}}&amp; {\mathbf{y}}\\
-{\mathbf{I}}_q &amp; \mathbf{0} &amp; \mathbf{0}
\end{bmatrix}
\begin{bmatrix}
-\mathbf{u} \\
-{\boldsymbol{\beta}}\\
1
\end{bmatrix}
\right\|^2 \\
&amp;=
\begin{bmatrix}
-\mathbf{u} \\
-{\boldsymbol{\beta}}\\
1
\end{bmatrix} '
\begin{bmatrix}
{\boldsymbol{\Lambda}}'\mathbf{Z}'\mathbf{Z}{\boldsymbol{\Lambda}}+{\mathbf{I}}&amp; {\boldsymbol{\Lambda}}'\mathbf{Z}'{\mathbf{X}}&amp; {\boldsymbol{\Lambda}}'\mathbf{Z}'{\mathbf{y}}\\
{\mathbf{X}}'\mathbf{Z}{\boldsymbol{\Lambda}}&amp; {\mathbf{X}}'{\mathbf{X}}&amp; {\mathbf{X}}'{\mathbf{y}}\\
{\mathbf{y}}'\mathbf{Z}{\boldsymbol{\Lambda}}&amp; {\mathbf{y}}'{\mathbf{X}}&amp; {\mathbf{y}}'{\mathbf{y}}
\end{bmatrix}
\begin{bmatrix}
-\mathbf{u} \\
-{\boldsymbol{\beta}}\\
1
\end{bmatrix} \\
&amp;= \left\|
\begin{bmatrix}
{\mathbf{R}}_{ZZ} &amp; {\mathbf{R}}_{ZX} &amp; \mathbf{r}_{Zy}\\
\mathbf{0} &amp; {\mathbf{R}}_{XX}' &amp; \mathbf{r}_{Xy}\\
\mathbf{0} &amp; \mathbf{0} &amp; r_{yy}
\end{bmatrix}
\begin{bmatrix}
-\mathbf{u} \\
-{\boldsymbol{\beta}}\\
1
\end{bmatrix}
\right\|^2\\
&amp;= \| \mathbf{r}_{Zy}-{\mathbf{R}}_{ZX}{\boldsymbol{\beta}}-{\mathbf{R}}_{ZZ}\mathbf{u} \|^2 +
\| \mathbf{r}_{Xy}-{\mathbf{R}}_{XX}{\boldsymbol{\beta}}\|^2 + r_{yy}^2 ,
\end{aligned}
\tag{B.37}\]</span></span></p>
<p>using the Cholesky factor of the blocked matrix,</p>
<p><span id="eq-bigCholfac"><span class="math display">\[
\begin{aligned}
{\boldsymbol{\Omega}}_\theta&amp;=
\begin{bmatrix}
{\boldsymbol{\Lambda}}_\theta'\mathbf{Z'Z}{\boldsymbol{\Lambda}}_\theta+{\mathbf{I}}&amp;
{\boldsymbol{\Lambda}}_\theta'\mathbf{Z'X} &amp; {\boldsymbol{\Lambda}}_\theta'\mathbf{Z'y} \\
\mathbf{X'Z}{\boldsymbol{\Lambda}}_\theta &amp; \mathbf{X'X} &amp; \mathbf{X'y} \\
\mathbf{y'Z}{\boldsymbol{\Lambda}}_\theta &amp; \mathbf{y'X} &amp; \mathbf{y'y}
\end{bmatrix}\\
&amp; =
\begin{bmatrix}
{\mathbf{R}}_{ZZ}' &amp; \mathbf{0} &amp; \mathbf{0} \\
{\mathbf{R}}_{ZX}' &amp; {\mathbf{R}}'_{XX} &amp; \mathbf{0} \\
\mathbf{r}_{Zy}' &amp; \mathbf{r}'_{Xy} &amp; r_{yy}
\end{bmatrix}
\begin{bmatrix}
{\mathbf{R}}_{ZZ} &amp; {\mathbf{R}}_{ZX} &amp; \mathbf{r}_{Zy} \\
\mathbf{0} &amp; {\mathbf{R}}_{XX} &amp; \mathbf{r}_{Xy} \\
\mathbf{0} &amp; \mathbf{0} &amp; r_{yy}
\end{bmatrix} .
\end{aligned}
\tag{B.38}\]</span></span></p>
<p>Note that the block in the upper left, <span class="math inline">\({\boldsymbol{\Lambda}}_\theta'\mathbf{Z'Z}{\boldsymbol{\Lambda}}_\theta+{\mathbf{I}}\)</span>, is positive definite even when <span class="math inline">\({\boldsymbol{\Lambda}}_\theta\)</span> is singular, because</p>
<p><span id="eq-Cholfacupperleft"><span class="math display">\[
\mathbf{u}'\left({\boldsymbol{\Lambda}}_\theta'\mathbf{Z'Z}{\boldsymbol{\Lambda}}_\theta+{\mathbf{I}}\right)\mathbf{u} = \left\|\mathbf{Z}{\boldsymbol{\Lambda}}_\theta\mathbf{u}\right\|^2
+\left\|\mathbf{u}\right\|^2
\tag{B.39}\]</span></span></p>
<p>and the first term is non-negative while the second is positive if <span class="math inline">\(\mathbf{u}\ne\mathbf{0}\)</span>.</p>
<p>Thus <span class="math inline">\({\mathbf{R}}_{ZZ}\)</span>, with positive diagonal elements, can be evaluated and its determinant, <span class="math inline">\(\left|{\mathbf{R}}_{ZZ}\right|\)</span>, is positive. This determinant appears in the marginal density of <span class="math inline">\({\mathcal{Y}}\)</span>, from which the likelihood of the parameters is evaluated.</p>
<p>To evaluate the likelihood,</p>
<p><span id="eq-likelihood-abstract"><span class="math display">\[
L({\boldsymbol{\theta}},{\boldsymbol{\beta}},\sigma|{\mathbf{y}}) = \int_\mathbf{u} f_{{\mathcal{Y}},{\mathcal{U}}}({\mathbf{y}},\mathbf{u})\, d\mathbf{u}
\tag{B.40}\]</span></span></p>
<p>we isolate the part of the joint density that depends on <span class="math inline">\(\mathbf{u}\)</span> and perform a change of variable</p>
<p><span id="eq-u-system"><span class="math display">\[
\mathbf{v}={\mathbf{R}}_{ZZ}\mathbf{u}+{\mathbf{R}}_{ZX}{\boldsymbol{\beta}}-\mathbf{r}_{Zy} .
\tag{B.41}\]</span></span></p>
<p>From the properties of the multivariate Gaussian distribution</p>
<p><span id="eq-likelihood-integral"><span class="math display">\[
\begin{multline*}
\int_{\mathbf{u}}\frac{1}{(2\pi\sigma^2)^{q/2}}
\exp\left(-\frac{\|{\mathbf{R}}_{ZZ}\mathbf{u}+{\mathbf{R}}_{ZX}{\boldsymbol{\beta}}-\mathbf{r}_{Zy}\|^2}{2\sigma^2}\right)
\,d\mathbf{u}\\
\begin{aligned}
&amp;= \int_{\mathbf{v}}\frac{1}{(2\pi\sigma^2)^{q/2}}
\exp\left(-\frac{\|\mathbf{v}\|^2}{2\sigma^2}\right)|{\mathbf{R}}_{ZZ}|^{-1}\,d\mathbf{v}\\
&amp;=|{\mathbf{R}}_{ZZ}|^{-1}
\end{aligned}
\end{multline*}
\tag{B.42}\]</span></span></p>
<p>from which we obtain the likelihood as</p>
<p><span id="eq-likelihood"><span class="math display">\[
L({\boldsymbol{\theta}},{\boldsymbol{\beta}},\sigma;{\mathbf{y}})=
\frac{|{\mathbf{R}}_{ZZ}|^{-1}}{(2\pi\sigma^2)^{n/2}}
\exp\left(-\frac{r_{yy}^2 + \|{\mathbf{R}}_{XX}({\boldsymbol{\beta}}-\widehat{{\boldsymbol{\beta}}})\|^2}{2\sigma^2}\right) ,
\tag{B.43}\]</span></span></p>
<p>where the conditional estimate, <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span>, given <span class="math inline">\({\boldsymbol{\theta}}\)</span>, satisfies <span class="math display">\[
{\mathbf{R}}_{XX}\widehat{{\boldsymbol{\beta}}} = \mathbf{r}_{Xy} .
\]</span></p>
<p>Setting <span class="math inline">\({\boldsymbol{\beta}}=\widehat{{\boldsymbol{\beta}}}\)</span> and taking the logarithm provides the estimate of <span class="math inline">\(\sigma^2\)</span>, given <span class="math inline">\({\boldsymbol{\theta}}\)</span>, as</p>
<p><span id="eq-sigma-hat"><span class="math display">\[
\widehat{\sigma^2}=\frac{r_\mathbf{yy}^2}{n}
\tag{B.44}\]</span></span></p>
<p>which gives the <em>profiled log-likelihood</em>, <span class="math inline">\(\ell({\boldsymbol{\theta}}|{\mathbf{y}})=\log L({\boldsymbol{\theta}},\widehat{{\boldsymbol{\beta}}},\widehat{\sigma})\)</span>, on the deviance scale, as</p>
<p><span id="eq-profiled-log-likelihood"><span class="math display">\[
-2\ell({\boldsymbol{\theta}}|{\mathbf{y}})=2\log(|{\mathbf{R}}_{ZZ}|) +
n\left(1+\log\left(\frac{2\pi r_{yy}^2({\boldsymbol{\theta}})}{n}\right)\right)
\tag{B.45}\]</span></span></p>
<p>One of the interesting aspects of this formulation is that it is not necessary to solve for the conditional estimate of <span class="math inline">\({\boldsymbol{\beta}}\)</span> or the conditional modes of the random effects when evaluating the log-likelihood. The two values needed for the log-likelihood evaluation, <span class="math inline">\(2\log(|{\mathbf{R}}_{ZZ}|)\)</span> and <span class="math inline">\(r_\mathbf{yy}^2\)</span>, are obtained directly from the diagonal elements of the Cholesky factor.</p>
<p>Furthermore, <span class="math inline">\({\boldsymbol{\Omega}}_{\theta}\)</span> and, from that, the Cholesky factor, <span class="math inline">\({\mathbf{R}}_{\theta}\)</span>, and the objective to be optimized can be evaluated for a given value of <span class="math inline">\({\boldsymbol{\theta}}\)</span> from</p>
<p><span id="eq-A"><span class="math display">\[
\mathbf{A} = \begin{bmatrix}
\mathbf{Z}^\prime\mathbf{Z} &amp; \mathbf{Z}^\prime{\mathbf{X}}&amp; \mathbf{Z}^\prime{\mathbf{y}}\\
{\mathbf{X}}^\prime\mathbf{Z} &amp; {\mathbf{X}}^\prime{\mathbf{X}}&amp; {\mathbf{X}}^\prime{\mathbf{y}}\\
{\mathbf{y}}^\prime\mathbf{Z} &amp; {\mathbf{y}}^\prime{\mathbf{X}}&amp; {\mathbf{y}}^\prime{\mathbf{y}}
\end{bmatrix}
\tag{B.46}\]</span></span></p>
<p>and <span class="math inline">\({\boldsymbol{\Lambda}}_{\theta}\)</span>.</p>
<p>In the <code>MixedModels</code> package the <code>LinearMixedModel</code> struct contains a symmetric blocked array in the <code>A</code> field and a similarly structured lower-triangular blocked array in the <code>L</code> field. Evaluation of the objective simply involves updating the template matrices, <span class="math inline">\({\boldsymbol{\Lambda}}_i, i=1,\dots,k\)</span> in the <code>ReMat</code> structures then updating <code>L</code> from <code>A</code> and the <span class="math inline">\(\lambda_i\)</span>.</p>
</section>
<section id="sec-REML" class="level2" data-number="B.8">
<h2 data-number="B.8" class="anchored" data-anchor-id="sec-REML"><span class="header-section-number">B.8</span> The REML criterion</h2>
<p>The so-called REML estimates of variance components are often preferred to the maximum likelihood estimates. (“REML” can be considered to be an acronym for “restricted” or “residual” maximum likelihood, although neither term is completely accurate because these estimates do not maximize a likelihood.) We can motivate the use of the REML criterion by considering a linear regression model,</p>
<p><span id="eq-20"><span class="math display">\[
{\mathcal{Y}}\sim{\mathcal{N}}({\mathbf{X}}{\boldsymbol{\beta}},\sigma^2{\mathbf{I}}_n),
\tag{B.47}\]</span></span></p>
<p>in which we typically estimate <span class="math inline">\(\sigma^2\)</span> as</p>
<p><span id="eq-21"><span class="math display">\[
\widehat{\sigma^2_R}=\frac{\|{\mathbf{y}}-{\mathbf{X}}\widehat{{\boldsymbol{\beta}}}\|^2}{n-p}
\tag{B.48}\]</span></span></p>
<p>even though the maximum likelihood estimate of <span class="math inline">\(\sigma^2\)</span> is</p>
<p><span id="eq-22"><span class="math display">\[
\widehat{\sigma^2_{L}}=\frac{\|{\mathbf{y}}-\vec
X\widehat{{\boldsymbol{\beta}}}\|^2}{n} .
\tag{B.49}\]</span></span></p>
<p>The argument for preferring <span class="math inline">\(\widehat{\sigma^2_R}\)</span> to <span class="math inline">\(\widehat{\sigma^2_{L}}\)</span> as an estimate of <span class="math inline">\(\sigma^2\)</span> is that the numerator in both estimates is the sum of squared residuals at <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span> and, although the residual vector, <span class="math inline">\({\mathbf{y}}-{\mathbf{X}}\widehat{{\boldsymbol{\beta}}}\)</span>, is an <span class="math inline">\(n\)</span>-dimensional vector, it satisfies <span class="math inline">\(p\)</span> linearly independent constraints, <span class="math inline">\({\mathbf{X}}'({\mathbf{y}}-{\mathbf{X}}\widehat{{\boldsymbol{\beta}}})=\mathbf{0}\)</span>. That is, the residual at <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}\)</span> is the projection of the observed response vector, <span class="math inline">\({\mathbf{y}}\)</span>, into an <span class="math inline">\((n-p)\)</span>-dimensional linear subspace of the <span class="math inline">\(n\)</span>-dimensional response space. The estimate <span class="math inline">\(\widehat{\sigma^2_R}\)</span> takes into account the fact that <span class="math inline">\(\sigma^2\)</span> is estimated from residuals that have only <span class="math inline">\(n-p\)</span> <em>degrees of freedom</em>.</p>
<p>Another argument often put forward for REML estimation is that <span class="math inline">\(\widehat{\sigma^2_R}\)</span> is an <em>unbiased</em> estimate of <span class="math inline">\(\sigma^2\)</span>, in the sense that the expected value of the estimator is equal to the value of the parameter. However, determining the expected value of an estimator involves integrating with respect to the density of the estimator and we have seen that densities of estimators of variances will be skewed, often highly skewed. It is not clear why we should be interested in the expected value of a highly skewed estimator. If we were to transform to a more symmetric scale, such as the estimator of the standard deviation or the estimator of the logarithm of the standard deviation, the REML estimator would no longer be unbiased. Furthermore, this property of unbiasedness of variance estimators does not generalize from the linear regression model to linear mixed models. This is all to say that the distinction between REML and ML estimates of variances and variance components is probably less important than many people believe.</p>
<p>Nevertheless it is worthwhile seeing how the computational techniques described in this chapter apply to the REML criterion because the REML parameter estimates <span class="math inline">\(\widehat{{\boldsymbol{\theta}}}_R\)</span> and <span class="math inline">\(\widehat{\sigma_R^2}\)</span> for a linear mixed model have the property that they would specialize to <span class="math inline">\(\widehat{\sigma^2_R}\)</span> from <a href="#eq-21" class="quarto-xref">Equation&nbsp;<span>B.48</span></a> for a linear regression model, as seen in <a href="intro.html#sec-dyestuff2lmm" class="quarto-xref"><span>Section 1.3.3</span></a>.</p>
<p>Although not usually derived in this way, the REML criterion (on the deviance scale) can be expressed as</p>
<p><span id="eq-23"><span class="math display">\[
d_R({\boldsymbol{\theta}},\sigma|{\mathbf{y}})=-2\log
\int_{\mathbb{R}^p}L({\boldsymbol{\theta}},{\boldsymbol{\beta}},\sigma|{\mathbf{y}})\,d{\boldsymbol{\beta}}.
\tag{B.50}\]</span></span></p>
<p>The REML estimates <span class="math inline">\(\widehat{{\boldsymbol{\theta}}}_R\)</span> and <span class="math inline">\(\widehat{\sigma_R^2}\)</span> minimize <span class="math inline">\(d_R({\boldsymbol{\theta}},\sigma|{\mathbf{y}})\)</span>.</p>
<p>To evaluate this integral we form an expansion, similar to <a href="#eq-likelihood" class="quarto-xref">Equation&nbsp;<span>B.43</span></a>, of <span class="math inline">\(r^2_{\theta,\beta}\)</span> about <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}_\theta\)</span></p>
<p><span id="eq-rsqbetathetaexp"><span class="math display">\[
r^2_{\theta,\beta}=r^2_\theta+\|{\mathbf{R}}_{XX}({\boldsymbol{\beta}}-\widehat{{\boldsymbol{\beta}}}_\theta)\|^2 .
\tag{B.51}\]</span></span></p>
<p>from which we can derive</p>
<p><span id="eq-betaintegral"><span class="math display">\[
\int_{\mathbb{R}^p}\frac{\exp\left(-\frac{r^2_{\theta,\beta}}{2\sigma^2}\right)}
{(2\pi\sigma^2)^{n/2}|{\mathbf{R}}_{ZZ}|} \,d{\boldsymbol{\beta}}=
\frac{\exp\left(-\frac{r^2_\theta}{2\sigma^2}\right)}
{(2\pi\sigma^2)^{(n-p)/2}|{\mathbf{R}}_{ZZ}||{\mathbf{R}}_X|}
\tag{B.52}\]</span></span></p>
<p>corresponding to a REML criterion on the deviance scale of</p>
<p><span id="eq-remldev"><span class="math display">\[
d_R({\boldsymbol{\theta}},\sigma|{\mathbf{y}})=(n-p)\log(2\pi\sigma^2)+
2\log\left(|{\mathbf{R}}_{ZZ}||{\mathbf{R}}_X|\right)+\frac{r^2_\theta}{\sigma^2} .
\tag{B.53}\]</span></span></p>
<p>Plugging in the conditional REML estimate, <span class="math inline">\(\widehat{\sigma^2}_R=r^2_\theta/(n-p)\)</span>, provides the profiled REML criterion</p>
<p><span id="eq-24"><span class="math display">\[
\tilde{d}_R({\boldsymbol{\theta}}|{\mathbf{y}})=
2\log\left(|{\mathbf{R}}_{ZZ}||{\mathbf{R}}_X|\right)+(n-p)
\left[1+\log\left(\frac{2\pi r^2_\theta}{n-p}\right)\right].
\tag{B.54}\]</span></span></p>
<p>The REML estimate of <span class="math inline">\({\boldsymbol{\theta}}\)</span> is</p>
<p><span id="eq-31"><span class="math display">\[
\widehat{{\boldsymbol{\theta}}}_R=\arg\min_{{\boldsymbol{\theta}}}\tilde{d}_R({\boldsymbol{\theta}}|{\mathbf{y}}) ,
\tag{B.55}\]</span></span></p>
<p>and the REML estimate of <span class="math inline">\(\sigma^2\)</span> is the conditional REML estimate of <span class="math inline">\(\sigma^2\)</span> at <span class="math inline">\(\widehat{{\boldsymbol{\theta}}}_R\)</span>,</p>
<p><span id="eq-remlsigmasq"><span class="math display">\[
\widehat{\sigma^2_R}=r^2_{\widehat\theta_R}/(n-p) .
\tag{B.56}\]</span></span></p>
<p>It is not entirely clear how one would define a “REML estimate” of <span class="math inline">\({\boldsymbol{\beta}}\)</span> because the REML criterion, <span class="math inline">\(d_R({\boldsymbol{\theta}},\sigma|{\mathbf{y}})\)</span>, defined in <a href="#eq-remldev" class="quarto-xref">Equation&nbsp;<span>B.53</span></a>, does not depend on <span class="math inline">\({\boldsymbol{\beta}}\)</span>. However, it is customary (and not unreasonable) to use <span class="math inline">\(\widehat{{\boldsymbol{\beta}}}_R=\widehat{{\boldsymbol{\beta}}}_{\widehat{{\boldsymbol{\theta}}}_R}\)</span> as the REML estimate of <span class="math inline">\({\boldsymbol{\beta}}\)</span>.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list" style="display: none">
<div id="ref-bates.maechler.etal:2015" class="csl-entry" role="listitem">
Bates, D., Maechler, M., Bolker, B. M., &amp; Walker, S. (2015). Fitting linear mixed-effects models using lme4. <em>Journal of Statistical Software</em>, <em>67</em>(1), 1–48. <a href="https://doi.org/10.18637/jss.v067.i01">https://doi.org/10.18637/jss.v067.i01</a>
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./datatables.html" class="pagination-link" aria-label="Working with data tables">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Working with data tables</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./aGHQ.html" class="pagination-link" aria-label="GLMM log-likelihood">
        <span class="nav-page-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">GLMM log-likelihood</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>